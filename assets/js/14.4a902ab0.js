(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{415:function(t,a,s){"use strict";s.r(a);var e=s(56),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"释放连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#释放连接"}},[t._v("#")]),t._v(" 释放连接")]),t._v(" "),s("h5",{attrs:{id:"客户a"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#客户a"}},[t._v("#")]),t._v(" 客户A")]),t._v(" "),s("h5",{attrs:{id:"服务器b"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务器b"}},[t._v("#")]),t._v(" 服务器B")]),t._v(" "),s("ul",[s("li",[t._v("A的应用进程向其TCP发出释放连接的报文，并停止再发送数据，主动释放连接(FIN = 1, seq = u),进入FIN-WAIT-1(终止等待1),等待B的确认。FIN报文不携带数据，并消耗一个序号")]),t._v(" "),s("li",[t._v("B收到连接释放报文段后发出确认报文（ACK = 1 ，seq = v, ack = u+1），B进入CLOSE-WAIT(关闭等待)状态。TCP处于"),s("strong",[t._v("半关闭状态")]),t._v(", 即A没有数据要发送了，但B要发送数据,A仍要接收。")]),t._v(" "),s("li",[t._v("A收到来自B的确认后，就进入FIN-WAIT-2(终止等待2)状态，等待B发送的连接释放报文段。")]),t._v(" "),s("li",[t._v("B发送连接释放报文段（FIN = 1, seq = w ,ack = u+1）,B必须重复上次已经发送过的确认号ack = u+ 1。 B进入LAST-ACK(最后确认)状态，等待A的确认。")]),t._v(" "),s("li",[t._v("A在收到B的连接释放报文段后，必须发出确认。确认报文段（ACK = 1, seq = u+1, ack = w+1）,然后进入TIME-WAIT（时间等待状态）,2MSL后才进入CLOSED状态。")])]),t._v(" "),s("p",[t._v("MSL: "),s("strong",[t._v("最长报文段寿命(Maximum Segment LifeTime)")]),t._v("。TCP允许不同的实现可根据具体情况设置不同的MSL。")]),t._v(" "),s("h4",{attrs:{id:"a在time-wait必须等待2msl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a在time-wait必须等待2msl"}},[t._v("#")]),t._v(" A在TIME-WAIT必须等待2MSL")]),t._v(" "),s("ul",[s("li",[t._v("为了保证A发送的最后一个ACK报文段能够达到B。")])])])}),[],!1,null,null,null);a.default=r.exports}}]);