(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{471:function(t,e,n){"use strict";n.r(e);var i=n(56),s=Object(i.a)({},(function(){var t=this.$createElement,e=this._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[e("p",[this._v("应用如何找到最合适的控件来处理事件？\n1.首先判断主窗口（keyWindow）自己是否能接受触摸事件\n2.触摸点是否在自己身上\n3.从后往前遍历子控件，重复前面的两个步骤（首先查找数组中最后一个元素）\n4.如果没有符合条件的子控件，那么就认为自己最合适处理")]),this._v(" "),e("p",[this._v("详述：1.主窗口接收到应用程序传递过来的事件后，首先判断自己能否接手触摸事件。如果能，那么在判断触摸点在不在窗口自己身上\n　　　2.如果触摸点也在窗口身上，那么窗口会从后往前遍历自己的子控件（遍历自己的子控件只是为了寻找出来最合适的view）\n　　　3.遍历到每一个子控件后，又会重复上面的两个步骤（传递事件给子控件，1.判断子控件能否接受事件，2.点在不在子控件上）\n　　　4.如此循环遍历子控件，直到找到最合适的view，如果没有更合适的子控件，那么自己就成为最合适的view。\n找到最合适的view后，就会调用该view的touches方法处理具体的事件。所以，只有找到最合适的view，把事件传递给最合适的view后，才会调用touches方法进行接下来的事件处理。找不到最合适的view，就不会调用touches方法进行事件处理。\n注意：之所以会采取从后往前遍历子控件的方式寻找最合适的view只是为了做一些循环优化。因为相比较之下，后添加的view在上面，降低循环次数")]),this._v(" "),e("p",[this._v("作者：VV木公子\n链接：https://www.jianshu.com/p/2e074db792ba\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")])])}),[],!1,null,null,null);e.default=s.exports}}]);