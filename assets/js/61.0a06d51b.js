(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{459:function(a,_,t){"use strict";t.r(_);var e=t(56),r=Object(e.a)({},(function(){var a=this,_=a.$createElement,t=a._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"gcd"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gcd"}},[a._v("#")]),a._v(" GCD")]),a._v(" "),t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),t("p",[a._v("全称是Grand Central Dispatch，可译为“中枢调度器”,纯C语言，提供了调用函数")]),a._v(" "),t("ul",[t("li",[a._v("GCD是苹果公司的多核并行运算解决方案")]),a._v(" "),t("li",[a._v("GCD会自动利用更多的CPU内核")]),a._v(" "),t("li",[a._v("GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）")]),a._v(" "),t("li",[a._v("只需编写GCD执行的任务，不需要编写任何线程管理代码")])]),a._v(" "),t("h2",{attrs:{id:"任务和队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#任务和队列"}},[a._v("#")]),a._v(" 任务和队列")]),a._v(" "),t("p",[t("strong",[a._v("GCD中有2个核心概念")])]),a._v(" "),t("ul",[t("li",[a._v("任务：执行什么操作")]),a._v(" "),t("li",[a._v("队列：用来存放任务")])]),a._v(" "),t("h3",{attrs:{id:"队列的类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列的类型"}},[a._v("#")]),a._v(" 队列的类型")]),a._v(" "),t("h4",{attrs:{id:"_1、并发队列-concurrent-dispatch-queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、并发队列-concurrent-dispatch-queue"}},[a._v("#")]),a._v(" 1、并发队列（Concurrent Dispatch Queue）")]),a._v(" "),t("ul",[t("li",[a._v("可以让多个任务"),t("strong",[a._v("并发执行")]),a._v(",开启多个"),t("strong",[a._v("子线程")])]),a._v(" "),t("li",[a._v("并发功能只有在异步函数（dispatch_async）下才有效")])]),a._v(" "),t("h4",{attrs:{id:"_2、串行队列-serial-dispatch-queue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、串行队列-serial-dispatch-queue"}},[a._v("#")]),a._v(" 2、串行队列（Serial Dispatch Queue）")]),a._v(" "),t("ul",[t("li",[a._v("任务按顺序执行，不回开启新线程")])]),a._v(" "),t("h3",{attrs:{id:"并发队列的创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发队列的创建"}},[a._v("#")]),a._v(" 并发队列的创建")]),a._v(" "),t("h4",{attrs:{id:"_1、手动创建并发队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、手动创建并发队列"}},[a._v("#")]),a._v(" 1、手动创建并发队列")]),a._v(" "),t("p",[t("code",[a._v('dispatch_queue_t queue = dispatch_queue_create("com.sooxie.queue", DISPATCH_QUEUE_CONCURRENT);')])]),a._v(" "),t("h4",{attrs:{id:"_2、全局并发队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、全局并发队列"}},[a._v("#")]),a._v(" 2、全局并发队列")]),a._v(" "),t("p",[t("code",[a._v("dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);")])]),a._v(" "),t("p",[a._v("全局并发队列的优先级")]),a._v(" "),t("ul",[t("li",[a._v("#define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高")]),a._v(" "),t("li",[a._v("#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认（中）")]),a._v(" "),t("li",[a._v("#define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低")]),a._v(" "),t("li",[a._v("#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台")])]),a._v(" "),t("h3",{attrs:{id:"串行队列的创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#串行队列的创建"}},[a._v("#")]),a._v(" 串行队列的创建")]),a._v(" "),t("h4",{attrs:{id:"_1、手动创建串行队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、手动创建串行队列"}},[a._v("#")]),a._v(" 1、手动创建串行队列")]),a._v(" "),t("p",[a._v("// 队列类型传递NULL或者DISPATCH_QUEUE_SERIAL")]),a._v(" "),t("p",[t("code",[a._v('dispatch_queue_t queue = dispatch_queue_create("com.sooxie.queue", NULL);')])]),a._v(" "),t("h4",{attrs:{id:"_2、主队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、主队列"}},[a._v("#")]),a._v(" 2、主队列")]),a._v(" "),t("p",[a._v("// 主队列中的任务，都会放到主线程中执行")]),a._v(" "),t("p",[t("code",[a._v("dispatch_queue_t queue = dispatch_get_main_queue();")])]),a._v(" "),t("h3",{attrs:{id:"同步、异步、并发、串行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步、异步、并发、串行"}},[a._v("#")]),a._v(" 同步、异步、并发、串行")]),a._v(" "),t("h4",{attrs:{id:"_1、同步和异步-能不能开启新的线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、同步和异步-能不能开启新的线程"}},[a._v("#")]),a._v(" 1、同步和异步（能不能开启新的线程）")]),a._v(" "),t("ul",[t("li",[a._v("同步：只是在"),t("strong",[a._v("当前线程")]),a._v("中执行任务，"),t("strong",[a._v("不具备")]),a._v("开启新线程的能力")]),a._v(" "),t("li",[a._v("异步：可以在"),t("strong",[a._v("新的线程")]),a._v("中执行任务，"),t("strong",[a._v("具备")]),a._v("开启新线程的能力")])]),a._v(" "),t("h4",{attrs:{id:"_2、并发和串行-任务的执行方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、并发和串行-任务的执行方式"}},[a._v("#")]),a._v(" 2、并发和串行（任务的执行方式）")]),a._v(" "),t("ul",[t("li",[a._v("并发：允许多个任务并发（同时）执行")]),a._v(" "),t("li",[a._v("串行：一个任务执行完毕后，再执行下一个任务")])]),a._v(" "),t("table",[t("thead",[t("tr",[t("th"),a._v(" "),t("th",[a._v("并发队列")]),a._v(" "),t("th",[a._v("手动创建的串行队列")]),a._v(" "),t("th",[a._v("主队列")])])]),a._v(" "),t("tbody",[t("tr",[t("td",[a._v("同步-sync")]),a._v(" "),t("td",[t("span",{staticStyle:{color:"tomato"}},[a._v("没有")]),a._v(" 开启新线程,"),t("span",{staticStyle:{color:"blue"}},[a._v("串行")]),a._v("执行任务")]),a._v(" "),t("td",[t("span",{staticStyle:{color:"tomato"}},[a._v("没有")]),a._v(" 开启新线程,"),t("span",{staticStyle:{color:"blue"}},[a._v("串行")]),a._v("执行任务")]),a._v(" "),t("td",[t("span",{staticStyle:{color:"tomato"}},[a._v("没有")]),a._v(" 开启新线程,"),t("span",{staticStyle:{color:"blue"}},[a._v("串行")]),a._v("执行任务")])]),a._v(" "),t("tr",[t("td",[a._v("异步-async")]),a._v(" "),t("td",[t("span",{staticStyle:{color:"green"}},[a._v("有")]),a._v("开启新线程,"),t("span",{staticStyle:{color:"#f7061acc"}},[a._v("并发")]),a._v("执行任务")]),a._v(" "),t("td",[t("span",{staticStyle:{color:"green"}},[a._v("有")]),a._v("开启新线程,"),t("span",{staticStyle:{color:"blue"}},[a._v("串行")]),a._v("执行任务")]),a._v(" "),t("td",[t("span",{staticStyle:{color:"tomato"}},[a._v("没有")]),a._v("有启新线程,"),t("span",{staticStyle:{color:"blue"}},[a._v("串行")]),a._v("执行任务")])])])]),a._v(" "),t("h4",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结：")]),a._v(" "),t("p",[a._v("在"),t("strong",[a._v("串行队列")]),a._v("中使用"),t("strong",[a._v("dispatch_sync")]),a._v("函数添加任务，会阻塞"),t("strong",[a._v("当前串行队列")]),a._v(",产生"),t("strong",[a._v("死锁")])]),a._v(" "),t("blockquote",[t("p",[a._v("串行队列FIFO（先进先出），当前串行队列会执行"),t("strong",[a._v("dispatch_sync")]),a._v("函数，而"),t("strong",[a._v("dispatch_sync")]),a._v("代码块的任务会等待串行队列中的"),t("strong",[a._v("dispatch_sync")]),a._v("执行后，造成互相等待死锁。")])]),a._v(" "),t("ul",[t("li",[a._v("1、主队列，不管是同步还是异步都"),t("strong",[a._v("不会开启新线程")]),a._v("，串行执行任务")]),a._v(" "),t("li",[a._v("2、手动创建的串行队列，异步执行"),t("strong",[a._v("会开启新线程")]),a._v("，运用多核提升执行效率，但任务是按序执行")]),a._v(" "),t("li",[a._v("3、并发队列，同步不会开启新线程且串行执行，"),t("strong",[a._v("异步会开启新线程")]),a._v("任务并发执行，效率最高")])]),a._v(" "),t("hr"),a._v(" "),t("h2",{attrs:{id:"执行任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行任务"}},[a._v("#")]),a._v(" 执行任务")]),a._v(" "),t("ol",[t("li",[a._v("定制任务\n"),t("ul",[t("li",[a._v("想要执行的任务")])])]),a._v(" "),t("li",[a._v("将任务添加到队列中\n"),t("ul",[t("li",[a._v("GCD会自动将队列中的任务取出，放到对应的线程中执行")]),a._v(" "),t("li",[a._v("任务的取出遵循队列的FIFO原则：先进先出，后进后出")])])])]),a._v(" "),t("h3",{attrs:{id:"gcd函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gcd函数"}},[a._v("#")]),a._v(" GCD函数")]),a._v(" "),t("p",[a._v("GCD执行任务的常用函数")]),a._v(" "),t("ul",[t("li",[a._v("queue：队列")]),a._v(" "),t("li",[a._v("block：任务")])]),a._v(" "),t("ol",[t("li",[a._v("同步执行："),t("code",[a._v("dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);")])]),a._v(" "),t("li",[a._v("异步执行："),t("code",[a._v("dispatch_async(dispatch_queue_t queue, dispatch_block_t block);")])]),a._v(" "),t("li",[a._v("栅栏函数："),t("code",[a._v("dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);")])])]),a._v(" "),t("h2",{attrs:{id:"队列组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列组"}},[a._v("#")]),a._v(" 队列组")]),a._v(" "),t("p",[a._v("多个异步操作都执行完毕后，再回到主线程执行操作")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("dispatch_group_t group =  dispatch_group_create();\ndispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    // 异步操作1\n});\ndispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{\n    // 1异步操作2\n});\ndispatch_group_notify(group, dispatch_get_main_queue(), ^{\n    // 多个任务执行完，通知回到主线程执行\n});\n")])])]),t("h2",{attrs:{id:"barrier-async"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#barrier-async"}},[a._v("#")]),a._v(" barrier-async")]),a._v(" "),t("p",[a._v("异步栅栏函数\n"),t("code",[a._v("dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);")])]),a._v(" "),t("ul",[t("li",[a._v("1、参数并发队列必须是自己通过dispatch_queue_cretate创建的")]),a._v(" "),t("li",[a._v("2、传入的是一个串行或是一个全局的并发队列，等同于dispatch_async函数的效果")])]),a._v(" "),t("h3",{attrs:{id:"作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[a._v("#")]),a._v(" 作用")]),a._v(" "),t("blockquote",[t("ul",[t("li",[a._v("Submits a barrier block for asynchronous execution on a dispatch queue.\n在调度队列上提交一个异步执行的barrier块")])])]),a._v(" "),t("p",[a._v("自己创建的并发队列中执行多个异步操作中加了一个栅栏，只有"),t("code",[a._v("dispatch_barrier_async")]),t("strong",[a._v("函数前")]),a._v("的异步操执行完后，才执行"),t("code",[a._v("dispatch_barrier_async")]),t("strong",[a._v("函数后")]),a._v("的异步操作")]),a._v(" "),t("h3",{attrs:{id:"多读单写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多读单写"}},[a._v("#")]),a._v(" 多读单写")]),a._v(" "),t("h4",{attrs:{id:"不添加栅栏函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不添加栅栏函数"}},[a._v("#")]),a._v(" 不添加栅栏函数")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('    dispatch_queue_t queue = dispatch_queue_create("com.sooxie.queue", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_async(queue, ^{\n        NSLog(@"Barrier前 - 读1");\n    });\n    dispatch_async(queue, ^{\n        NSLog(@"Barrier前 - 读2");\n    });\n    dispatch_async(queue, ^{\n        NSLog(@"Barrier前 - 读3");\n    });\n    //此处相当于加了一个栅栏， 只有栅栏块的代码执行完后才可以执行后面的异步操作\n//    dispatch_barrier_async(queue, ^{\n//        NSLog(@"---- Barrier Block 写 ----");\n//    });\n    dispatch_async(queue, ^{\n        NSLog(@"Barrier后 - 读1");\n    });\n    dispatch_async(queue, ^{\n        NSLog(@"Barrier后 - 读2");\n    });\n    dispatch_async(queue, ^{\n        NSLog(@"Barrier后 - 读3");\n    });\n')])])]),t("p",[a._v("输出可能结果")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Barrier前 - 读1\nBarrier前 - 读3\nBarrier后 - 读1\nBarrier后 - 读2\nBarrier后 - 读3\nBarrier前 - 读2\n")])])]),t("h4",{attrs:{id:"添加栅栏函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#添加栅栏函数"}},[a._v("#")]),a._v(" 添加栅栏函数")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('    \n    dispatch_queue_t queue = dispatch_queue_create("com.sooxie.queue", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_async(queue, ^{\n        NSLog(@"Barrier前 - 读1");\n    });\n    dispatch_async(queue, ^{\n        NSLog(@"Barrier前 - 读2");\n    });\n    dispatch_async(queue, ^{\n        NSLog(@"Barrier前 - 读3");\n    });\n    //此处相当于加了一个栅栏， 只有栅栏块的代码执行完后才可以执行后面的异步操作\n    dispatch_barrier_async(queue, ^{\n        NSLog(@"---- Barrier Block 写 ----");\n    });\n    dispatch_async(queue, ^{\n        NSLog(@"Barrier后 - 读1");\n    });\n    dispatch_async(queue, ^{\n        NSLog(@"Barrier后 - 读2");\n    });\n    dispatch_async(queue, ^{\n        NSLog(@"Barrier后 - 读3");\n    });\n')])])]),t("p",[a._v("输出可能结果")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Barrier前 - 读1\nBarrier前 - 读3\nBarrier前 - 读2\n---- Barrier Block 写 ----\nBarrier后 - 读2\nBarrier后 - 读3\nBarrier后 - 读1\n")])])]),t("p",[a._v("dispatch_barrier_async前面的函数执行完才执行后面的异步操作")])])}),[],!1,null,null,null);_.default=r.exports}}]);